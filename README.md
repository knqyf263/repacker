# repacker
Automate the creation of methods that copy from src struct to target struct

<!-- TOC -->

- [repacker](#repacker)
- [Feature](#feature)
- [Usage](#usage)
    - [Basic Usage](#basic-usage)
    - [Struct tag](#struct-tag)
    - [Different Type](#different-type)
    - [Nested struct](#nested-struct)
    - [go generate](#go-generate)

<!-- /TOC -->

# Feature
- Copy fields with the same filed name
- Use the struct tag for different field names
- Converte type as much as possible (e.g. time.time → string)
- Support vendor directory
- Support tne nested struct

# Usage
## Basic Usage 
Two structs that have the same field.  
See [example](./example/simple)


```
$ cd example/simple
$ cat foo/foo.go
package foo

type FooSimple struct {
        ID     int
        Name   string
        Detail string
}

$ cat bar/bar.go
package bar

type BarSimple struct {
        ID     int
        Name   string
        Detail string
}
```

You can specify src type such as ${import_path}.${struct_name}  
e.g. github.com/knqyf263/test_repacker.Bar

Run repacker.

```
$ repacker -dst=FooSimple -src=github.com/knqyf263/repacker/example/simple/bar.BarSimple foo/
```

Automatically creates a method that copy from `BarSimple` to `FooSimple`.

```
$ cat foo/foosimple_repack.go
// Code generated by "repacker -dst=FooSimple -src=github.com/knqyf263/repacker/example/simple/bar.BarSimple foo/"; DO NOT EDIT

package foo

import "github.com/knqyf263/repacker/example/simple/bar"

// NewFooSimpleFromBarBarSimple creates *FooSimple from *bar.BarSimple
func NewFooSimpleFromBarBarSimple(s *bar.BarSimple) *FooSimple {
        return &FooSimple{
                ID:     s.ID,
                Name:   s.Name,
                Detail: s.Detail,
        }
}
```

## Struct tag
Add the same struct tag to the fields you want to copy
See [example](./example/tag)

```
$ cd example/tag
$ cat foo/foo.go
package foo

type FooTag struct {
        ID   int
        Name string
        Foo  string `repack:"foo"`
}

$ cat bar/bar.go
package bar

type BarTag struct {
        ID   int
        Name string
        Bar  string `repack:"foo"`
}
```

Run repacker.

```
$ repacker -dst=FooTag -src=github.com/knqyf263/repacker/example/tag/bar.BarTag foo/
repacker: Generating...
repacker: Lookup bar.BarTag
repacker: Lookup foo.FooTag
```


```
$ cat foo/footag_repack.go
// Code generated by "repacker -dst=FooTag -src=github.com/knqyf263/repacker/example/tag/bar.BarTag foo/"; DO NOT EDIT

package foo

import "github.com/knqyf263/repacker/example/tag/bar"

// NewFooTagFromBarBarTag creates *FooTag from *bar.BarTag
func NewFooTagFromBarBarTag(s *bar.BarTag) *FooTag {
        return &FooTag{
                ID:   s.ID,
                Name: s.Name,
                Foo:  s.Bar,
        }
}
```

## Different Type
Converte types as much as possible (e.g. time.time → string)  
See [example](./example/conversion).

```
$ cd example/conversion
$ cat foo/foo.go
package foo

type Foo struct {
        ID        int
        Name      string
        CreatedAt *string
}

$ cat bar/bar.go
package bar

import "time"

type Bar struct {
        ID   int
        Name string
        CreatedAt time.Time
}
```

Run repacker
```
$ repacker -dst=FooConversion -src=github.com/knqyf263/repacker/example/conversion/bar.BarConversion foo/
repacker: Generating...
repacker: Lookup bar.BarConversion
repacker: Lookup foo.FooConversion
```

```
$ cat foo/fooconversion_repack.go
// Code generated by "repacker -dst=FooConversion -src=github.com/knqyf263/repacker/example/conversion/bar.BarConversion foo/"; DO NOT EDIT

package foo

import (
        "fmt"

        "github.com/knqyf263/repacker/example/conversion/bar"
)

// NewFooConversionFromBarBarConversion creates *FooConversion from *bar.BarConversion
func NewFooConversionFromBarBarConversion(s *bar.BarConversion) *FooConversion {
        createdAt := fmt.Sprint(s.CreatedAt)
        return &FooConversion{
                ID:        s.ID,
                Name:      s.Name,
                CreatedAt: &createdAt,
        }
}
```

## Nested struct
If it is nested, it will recursively generate code automatically.
See [example](./example/nested).

```
$ cd example/nested
$ cat foo/foo.go
package foo

type Foo struct {
        ID   int
        Name string
        Nest NestedFoo
}

type NestedFoo struct {
        ID int
}

$ cat bar/bar.go
package bar

type Bar struct {
        ID   int
        Name string
        Nest NestedBar
}

type NestedBar struct {
        ID int
}
```

Run repacker

```
repacker -dst=Foo -src=github.com/knqyf263/repacker/example/nested/bar.Bar foo/ 
repacker: Generating...
repacker: Lookup bar.Bar
repacker: Lookup foo.Foo
repacker: Lookup bar.NestedBar
repacker: Lookup foo.NestedFoo
```


```
$ cat foo/foo_repack.go
// Code generated by "repacker -dst=Foo -src=github.com/knqyf263/repacker/example/nested/bar.Bar foo/"; DO NOT EDIT

package foo

import "github.com/knqyf263/repacker/example/nested/bar"

// NewNestedFooFromBarNestedBar creates *NestedFoo from *bar.NestedBar
func NewNestedFooFromBarNestedBar(s *bar.NestedBar) *NestedFoo {
        return &NestedFoo{
                ID: s.ID,
        }
}

// NewFooFromBarBar creates *Foo from *bar.Bar
func NewFooFromBarBar(s *bar.Bar) *Foo {
        return &Foo{
                ID:   s.ID,
                Name: s.Name,
                Nest: *NewNestedFooFromBarNestedBar(&s.Nest),
        }
}
```

## go generate
Generate code by `go generate`

```
$ cd example/conversion
$ cat foo/foo.go
package foo

//go:generate repacker -dst=FooConversion -src=github.com/knqyf263/repacker/example/conversion/bar.BarConversion

type Foo struct {
        ID   int
        Name string
        Foo  string `repack:"foo"`
}
```

```
$ go generate ./...
```
